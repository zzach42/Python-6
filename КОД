class Domino:
    #класс для кости и проверки на дурака

    def __init__(self, value):
        self.value = value
        self._validate()

    def _validate(self):
        #проверка корректности
        if len(self.value) != 2 or not self.value.isdigit():
            raise ValueError(f"Некорректная кость: {self.value}")
        a, b = map(int, self.value)
        if not (0 <= a <= 6 and 0 <= b <= 6):
            raise ValueError(f"Значения кости {self.value} должны быть от 0 до 6")

    def normalized(self):
        #Возвращает нормализованное представление (меньшее число первое)
        a, b = map(int, self.value)
        return self.value if a <= b else self.value[::-1]

    def __str__(self):
        return self.value


class DominoSet:
    #класс для работы с набором костей домино

    def __init__(self):
        self.dominoes = []
        self._unique_check = set()

    def add_domino(self, domino_value):
        #проверка на повторение костей
        domino = Domino(domino_value)
        norm = domino.normalized()

        if norm in self._unique_check:
            raise ValueError(f"Дубликат кости: {norm}")

        self.dominoes.append(domino)
        self._unique_check.add(norm)

    def validate(self):
        #проверка количества
        if not self.dominoes:
            raise ValueError("Не введено ни одной кости")

    def get_dominoes(self):
        return self.dominoes


class DominoGraph:
    #класс для представления графа домино и поиска пути

    def __init__(self, dominoes):
        self.graph = {}
        self.degrees = {}
        self._build_graph(dominoes)

    def _build_graph(self, dominoes):
        #строительство графа смежности и подсчет степени вершин
        for domino in dominoes:
            a, b = map(int, domino.value)
            self._add_edge(a, b)
            self._add_edge(b, a)

    def _add_edge(self, a, b):
        #доб ребро графа
        if a not in self.graph:
            self.graph[a] = []
        self.graph[a].append(b)
        self.degrees[a] = self.degrees.get(a, 0) + 1

    def find_eulerian_path(self):
        #йлеров путь
        odd_nodes = self._find_odd_degree_nodes()

        if not self._has_eulerian_path(odd_nodes):
            return None

        start_node = self._get_start_node(odd_nodes)
        return self._find_path(start_node)

    def _find_odd_degree_nodes(self):
        #ершины с нечет степенью
        return [node for node in self.degrees if self.degrees[node] % 2 != 0]

    def _has_eulerian_path(self, odd_nodes):
        #условия сущ пути
        return len(odd_nodes) in (0, 2)

    def _get_start_node(self, odd_nodes):
        #нач вершина для описка пути
        return odd_nodes[0] if odd_nodes else next(iter(self.degrees), None)

    def _find_path(self, start_node):
        #ищет путь на основе стека
        path = []
        stack = [start_node]
        temp_graph = {k: v.copy() for k, v in self.graph.items()}

        while stack:
            current = stack[-1]
            if temp_graph.get(current):
                next_node = temp_graph[current].pop()
                temp_graph[next_node].remove(current)
                stack.append(next_node)
            else:
                path.append(stack.pop())

        return path[::-1]


class DominoChainBuilder:
    #цепь из набора домино

    def __init__(self, domino_set):
        self.domino_set = domino_set
        self.dominoes = domino_set.get_dominoes()

    def build_chain(self):
        #пострйока цепи домино
        graph = DominoGraph(self.dominoes)
        path = graph.find_eulerian_path()

        if not path:
            return None

        return self._reconstruct_chain(path)

    def _reconstruct_chain(self, path):
        #Восстановление последовательность костей по пути в графе
        chain = []
        used = [False] * len(self.dominoes)

        for i in range(len(path) - 1):
            a, b = path[i], path[i + 1]
            domino = self._find_matching_domino(a, b, used)
            if domino:
                chain.append(domino)

        return chain if len(chain) == len(self.dominoes) else None

    def _find_matching_domino(self, a, b, used):
    #Находит подходящую неиспользованную кость
        for i, domino in enumerate(self.dominoes):
            if not used[i]:
                x, y = map(int, domino.value)
                if (x == a and y == b):
                    used[i] = True
                    return domino.value
                if (y == a and x == b):
                    used[i] = True
                    return domino.value[::-1]
        return None


class DominoGame:
    #основной класс игры

    def __init__(self):
        self.domino_set = DominoSet()
        self.ui = DominoUI(self)

    def run(self):
        #игровой цикл начало
        self.ui.show_welcome()
        self.ui.main_loop()

    def process_input(self, input_str):
        #ввод пользователя
        self.domino_set = DominoSet()  # Сбрасываем набор

        for d in input_str.split(","):
            if d.strip():
                self.domino_set.add_domino(d.strip())

        self.domino_set.validate()

        builder = DominoChainBuilder(self.domino_set)
        chain = builder.build_chain()

        return chain


class DominoUI:
    #взаим с пользв

    def __init__(self, game):
        self.game = game

    def show_welcome(self):
        print("╔════════════════════════════════════╗")
        print("║      ДОМИНО: ПРОВЕРКА ЦЕПИ        ║")
        print("╚════════════════════════════════════╝")
        print("Введите кости домино через запятую (например: 12, 34, 56)")

    def main_loop(self):
        #ввод вывад
        while True:
            try:
                input_str = self._get_user_input()
                if not input_str:
                    continue

                chain = self.game.process_input(input_str)
                self._show_result(chain)

            except ValueError as e:
                print(f"Ошибка: {e}")
            except KeyboardInterrupt:
                print("\nИгра завершена.")
                break
            except Exception as e:
                print(f"Неожиданная ошибка: {e}")

    def _get_user_input(self):
        #ввод от польз
        input_str = input("> ").strip()
        if not input_str:
            print("Ошибка: введите хотя бы одну кость!")
        return input_str

    def _show_result(self, chain):
        #реузльтатыыыыы
        if chain:
            result = "Можно: " + ", ".join(chain)
            border = "═" * (len(result) + 2)
            print(f"\nРезультат:\n╔{border}╗\n║ {result} ║\n╚{border}╝\n")
        else:
            print("\nРезультат: Нельзя выложить в ряд\n")


# Запуск игры
if __name__ == "__main__":
    game = DominoGame()
    game.run()
